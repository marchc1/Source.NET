#if !CLIENT_DLL && !GAME_DLL
global using EHANDLE = Source.Common.BaseHandle; // < Intellisense compatibility
#endif

global using static Game.Shared.SharedDefs;

using Source;
using Source.Common;

using System.Runtime.CompilerServices;

namespace Game.Shared;

using Source.Common.Mathematics;
using Source.Common.Networking;

using System;
using System.Numerics;

[Flags]
public enum WeaponFlags
{
	SelectionEmpty = 1 << 0,
	NoAutoReload = 1 << 1,
	NoAutoSwitchEmpty = 1 << 2,
	LimitInWorld = 1 << 3,
	Exhaustible = 1 << 4,
	DoHitLocationDmg = 1 << 5,
	NoAmmoPickups = 1 << 6,
	NoItemPickup = 1 << 7,
}
/// <summary>
/// BaseEntity.eflags
/// </summary>
[Flags]
public enum EFL : uint
{
	/// <summary>This entity is marked for death -- allows safe deletion</summary>
	KillMe = 1 << 0,
	/// <summary>Entity is dormant, no updates to client</summary>
	Dormant = 1 << 1,
	/// <summary>Noclip command is active</summary>
	NoClipActive = 1 << 2,
	/// <summary>Model is setting up its bones</summary>
	SettingUpBones = 1 << 3,
	/// <summary>Special entity not deleted on restart</summary>
	KeepOnRecreateEntities = 1 << 4,
	/// <summary>One of the child entities is a player</summary>
	HasPlayerChild = 1 << 5,
	/// <summary>Client-only: update shadow</summary>
	DirtyShadowUpdate = 1 << 6,
	/// <summary>Another entity watches events on this entity</summary>
	Notify = 1 << 7,
	/// <summary>Transmit entity even if it has no model</summary>
	ForceCheckTransmit = 1 << 8,
	/// <summary>Set on frozen bots</summary>
	BotFrozen = 1 << 9,
	/// <summary>Non-networked entity</summary>
	ServerOnly = 1 << 10,
	/// <summary>Don't attach the edict automatically</summary>
	NoAutoEdictAttach = 1 << 11,
	/// <summary>Dirty absolute transform</summary>
	DirtyAbsTransform = 1 << 12,
	/// <summary>Dirty absolute velocity</summary>
	DirtyAbsVelocity = 1 << 13,
	/// <summary>Dirty angular velocity</summary>
	DirtyAbsAngVelocity = 1 << 14,
	/// <summary>Dirty surrounding collision bounds</summary>
	DirtySurroundingCollisionBounds = 1 << 15,
	/// <summary>Dirty spatial partition</summary>
	DirtySpatialPartition = 1 << 16,
	/// <summary>Entity is in the skybox</summary>
	InSkybox = 1 << 17,
	/// <summary>Show up in partition even when not solid</summary>
	UsePartitionWhenNotSolid = 1 << 18,
	/// <summary>Entity is floating in fluid</summary>
	TouchingFluid = 1 << 19,
	/// <summary>Being lifted by barnacle</summary>
	IsBeingLiftedByBarnacle = 1 << 20,
	/// <summary>Not pushed by rotorwash</summary>
	NoRotorWashPush = 1 << 21,
	/// <summary>Entity has no think function</summary>
	NoThinkFunction = 1 << 22,
	/// <summary>Skip physics simulation</summary>
	NoGamePhysicsSimulation = 1 << 23,
	/// <summary>Check untouch</summary>
	CheckUntouch = 1 << 24,
	/// <summary>Don't block NPC line-of-sight</summary>
	DontBlockLOS = 1 << 25,
	/// <summary>NPCs shouldn't walk on this entity</summary>
	DontWalkOn = 1 << 26,
	/// <summary>Entity shouldn't dissolve</summary>
	NoDissolve = 1 << 27,
	/// <summary>Mega physcannon can't ragdoll this</summary>
	NoMegaPhysCannonRagdoll = 1 << 28,
	/// <summary>Don't adjust velocity in water</summary>
	NoWaterVelocityChange = 1 << 29,
	/// <summary>Physcannon can't pick up or punt</summary>
	NoPhysCannonInteraction = 1 << 30,
	/// <summary>Ignore forces from physics damage</summary>
	NoDamageForces = 1u << 31
}

public enum HudPrint
{
	Notify = 1,
	Console = 2,
	Talk = 3,
	Center = 4
}

[Flags]
public enum DamageType : int
{
	Any = 0,
	/// <summary>
	/// generic damage -- do not use if you want players to flinch and bleed!
	/// </summary>
	Generic = 0,

	/// <summary>
	/// crushed by falling or moving object.
	/// <br/>
	/// NOTE: It's assumed crush damage is occurring as a result of physics collision, so no extra physics force is generated by crush damage.
	/// <br/>
	/// DON'T use <see cref="Crush"/> when damaging entities unless it's the result of a physics collision. You probably want <see cref="Club"/> instead.
	/// </summary>
	Crush = (1 << 0),

	/// <summary>
	/// shot
	/// </summary>
	Bullet = (1 << 1),

	/// <summary>
	/// cut, clawed, stabbed
	/// </summary>
	Slash = (1 << 2),

	/// <summary>
	/// heat burned
	/// </summary>
	Burn = (1 << 3),

	/// <summary>
	/// hit by a vehicle
	/// </summary>
	Vehicle = (1 << 4),

	/// <summary>
	/// fell too far
	/// </summary>
	Fall = (1 << 5),

	/// <summary>
	/// explosive blast damage
	/// </summary>
	Blast = (1 << 6),

	/// <summary>
	/// crowbar, punch, headbutt
	/// </summary>
	Club = (1 << 7),

	/// <summary>
	/// electric shock
	/// </summary>
	Shock = (1 << 8),

	/// <summary>
	/// sound pulse shockwave
	/// </summary>
	Sonic = (1 << 9),

	/// <summary>
	/// laser or other high energy beam
	/// </summary>
	EnergyBeam = (1 << 10),

	/// <summary>
	/// Prevent a physics force
	/// </summary>
	PreventPhysicsForce = (1 << 11),

	/// <summary>
	/// with this bit OR'd in, no damage type will be able to gib victims upon death
	/// </summary>
	NeverGib = (1 << 12),

	/// <summary>
	/// with this bit OR'd in, any damage type can be made to gib victims upon death.
	/// </summary>
	AlwaysGib = (1 << 13),

	/// <summary>
	/// Drowning
	/// </summary>
	Drown = (1 << 14),

	/// <summary>
	/// slows affected creature down
	/// </summary>
	Paralyze = (1 << 15),

	/// <summary>
	/// nerve toxins, very bad
	/// </summary>
	NerveGas = (1 << 16),

	/// <summary>
	/// blood poisoning - heals over time like drowning damage
	/// </summary>
	Poison = (1 << 17),

	/// <summary>
	/// radiation exposure
	/// </summary>
	Radiation = (1 << 18),

	/// <summary>
	/// drowning recovery
	/// </summary>
	DrownRecover = (1 << 19),

	/// <summary>
	/// toxic chemicals or acid burns
	/// </summary>
	Acid = (1 << 20),

	/// <summary>
	/// in an oven
	/// </summary>
	SlowBurn = (1 << 21),

	/// <summary>
	/// with this bit OR'd in, no ragdoll will be created, and the target will be quietly removed.
	/// <br/>
	/// use this to kill an entity that you've already got a server-side ragdoll for
	/// </summary>
	RemoveNoRagdoll = (1 << 22),

	/// <summary>
	/// Hit by manipulator. Usually doesn't do any damage.
	/// </summary>
	Physgun = (1 << 23),

	/// <summary>
	/// Shot by Cremator
	/// </summary>
	Plasma = (1 << 24),

	/// <summary>
	/// Hit by the airboat's gun
	/// </summary>
	Airboat = (1 << 25),

	/// <summary>
	/// Dissolving
	/// </summary>
	Dissolve = (1 << 26),

	/// <summary>
	/// A blast on the surface of water that cannot harm things underwater
	/// </summary>
	BlastSurface = (1 << 27),

	Direct = (1 << 28),

	/// <summary>
	/// not quite a bullet. Little, rounder, different.
	/// </summary>
	Buckshot = (1 << 29)
}


public enum ObserverMode
{
	None,
	DeathCam,
	FreezeCam,
	Fixed,
	InEye,
	Chase,
	PointOfInterest,
	Roaming,
	Num
}

public enum UseType
{
	Off,
	On,
	Set,
	Toggle
}

public class ViewVectors
{
	public ViewVectors() { }
	public ViewVectors(
	 Vector3 view,
	 Vector3 hullMin,
	 Vector3 hullMax,
	 Vector3 duckHullMin,
	 Vector3 duckHullMax,
	 Vector3 duckView,
	 Vector3 obsHullMin,
	 Vector3 obsHullMax,
	 Vector3 deadViewHeight
	) {
		View = view;
		HullMin = hullMin;
		HullMax = hullMax;
		DuckHullMin = duckHullMin;
		DuckHullMax = duckHullMax;
		DuckView = duckView;
		ObsHullMin = obsHullMin;
		ObsHullMax = obsHullMax;
		DeadViewHeight = deadViewHeight;
	}
	public Vector3 View;
	public Vector3 HullMin;
	public Vector3 HullMax;
	public Vector3 DuckHullMin;
	public Vector3 DuckHullMax;
	public Vector3 DuckView;
	public Vector3 ObsHullMin;
	public Vector3 ObsHullMax;
	public Vector3 DeadViewHeight;
}

public static class SharedDefs
{
#if CLIENT_DLL || GAME_DLL
	public static Vector3 VEC_VIEW_SCALED(BasePlayer player) => (g_pGameRules.GetViewVectors().View * player.GetModelScale());
	public static Vector3 VEC_HULL_MIN_SCALED(BasePlayer player) => (g_pGameRules.GetViewVectors().HullMin * player.GetModelScale());
	public static Vector3 VEC_HULL_MAX_SCALED(BasePlayer player) => (g_pGameRules.GetViewVectors().HullMax * player.GetModelScale());
	public static Vector3 VEC_DUCK_HULL_MIN_SCALED(BasePlayer player) => (g_pGameRules.GetViewVectors().DuckHullMin * player.GetModelScale());
	public static Vector3 VEC_DUCK_HULL_MAX_SCALED(BasePlayer player) => (g_pGameRules.GetViewVectors().DuckHullMax * player.GetModelScale());
	public static Vector3 VEC_DUCK_VIEW_SCALED(BasePlayer player) => (g_pGameRules.GetViewVectors().DuckView * player.GetModelScale());
	public static Vector3 VEC_OBS_HULL_MIN_SCALED(BasePlayer player) => (g_pGameRules.GetViewVectors().ObsHullMin * player.GetModelScale());
	public static Vector3 VEC_OBS_HULL_MAX_SCALED(BasePlayer player) => (g_pGameRules.GetViewVectors().ObsHullMax * player.GetModelScale());
	public static Vector3 VEC_DEAD_VIEWHEIGHT_SCALED(BasePlayer player) => (g_pGameRules.GetViewVectors().DeadViewHeight * player.GetModelScale());

	public static ref Vector3 VEC_VIEW => ref g_pGameRules.GetViewVectors().View;
	public static ref Vector3 VEC_HULL_MIN => ref g_pGameRules.GetViewVectors().HullMin;
	public static ref Vector3 VEC_HULL_MAX => ref g_pGameRules.GetViewVectors().HullMax;
	public static ref Vector3 VEC_DUCK_HULL_MIN => ref g_pGameRules.GetViewVectors().DuckHullMin;
	public static ref Vector3 VEC_DUCK_HULL_MAX => ref g_pGameRules.GetViewVectors().DuckHullMax;
	public static ref Vector3 VEC_DUCK_VIEW => ref g_pGameRules.GetViewVectors().DuckView;
	public static ref Vector3 VEC_OBS_HULL_MIN => ref g_pGameRules.GetViewVectors().ObsHullMin;
	public static ref Vector3 VEC_OBS_HULL_MAX => ref g_pGameRules.GetViewVectors().ObsHullMax;
#else
	public static Vector3 VEC_VIEW_SCALED(object player) => throw new NotImplementedException();
	public static Vector3 VEC_HULL_MIN_SCALED(object player) => throw new NotImplementedException();
	public static Vector3 VEC_HULL_MAX_SCALED(object player) => throw new NotImplementedException();
	public static Vector3 VEC_DUCK_HULL_MIN_SCALED(object player) => throw new NotImplementedException();
	public static Vector3 VEC_DUCK_HULL_MAX_SCALED(object player) => throw new NotImplementedException();
	public static Vector3 VEC_DUCK_VIEW_SCALED(object player) => throw new NotImplementedException();
	public static Vector3 VEC_OBS_HULL_MIN_SCALED(object player) => throw new NotImplementedException();
	public static Vector3 VEC_OBS_HULL_MAX_SCALED(object player) => throw new NotImplementedException();
	public static Vector3 VEC_DEAD_VIEWHEIGHT_SCALED(object player) => throw new NotImplementedException();

	public static ref Vector3 VEC_VIEW => throw new NotImplementedException();
	public static ref Vector3 VEC_HULL_MIN => throw new NotImplementedException();
	public static ref Vector3 VEC_HULL_MAX => throw new NotImplementedException();
	public static ref Vector3 VEC_DUCK_HULL_MIN => throw new NotImplementedException();
	public static ref Vector3 VEC_DUCK_HULL_MAX => throw new NotImplementedException();
	public static ref Vector3 VEC_DUCK_VIEW => throw new NotImplementedException();
	public static ref Vector3 VEC_OBS_HULL_MIN => throw new NotImplementedException();
	public static ref Vector3 VEC_OBS_HULL_MAX => throw new NotImplementedException();
#endif

	public const int MAX_CONTEXT_LENGTH = 32;
	public const int NO_THINK_CONTEXT = -1;

	public const int SIMULATION_TIME_WINDOW_BITS = 8;

	public const int NOINTERP_PARITY_MAX = 4;
	public const int NOINTERP_PARITY_MAX_BITS = 2;
	public const int ANIMATION_CYCLE_BITS = 15;

	public const float PLAYER_FATAL_FALL_SPEED = 1024;        // approx 60 feet
	public const float PLAYER_MAX_SAFE_FALL_SPEED = 580;      // approx 20 feet
	public const float PLAYER_LAND_ON_FLOATING_OBJECT = 200;  // Can go another 200 units without getting hurt
	public const float PLAYER_MIN_BOUNCE_SPEED = 200;
	public const float PLAYER_FALL_PUNCH_THRESHOLD = 350;     // won't punch player's screen/make scrape noise unless player falling at least this fast.
	public const float DAMAGE_FOR_FALL_SPEED = 100.0f / (PLAYER_FATAL_FALL_SPEED - PLAYER_MAX_SAFE_FALL_SPEED); // damage per unit per second.

	public const int MAX_CLIMB_SPEED = 200;

	public const int TICK_NEVER_THINK = -1;


	public const float AUTOAIM_SCALE_DEFAULT = 1.0f;
	public const float AUTOAIM_SCALE_DIRECT_ONLY = 0.0f;


	public const int MAX_VIEWMODELS = 3;
	public const int MAX_BEAM_ENTS = 10;
	public const int MAX_WEAPONS = 256;
	public const int MAX_WEAPON_SLOTS = 6;
	public const int MAX_WEAPON_POSITIONS = 20;
	public const int MAX_ITEMS = 5;
	public const int WEAPON_NOCLIP = -1;

	public const float TIME_TO_DUCK = 0.4f;
	public const float TIME_TO_UNDUCK = 0.2f;
	public const float TIME_TO_UNDUCK_MS = 200.0f;


	public const int NUM_AUDIO_LOCAL_SOUNDS = 8;

	public const int MAX_SUIT_DEVICES = 3;
	public const int MAX_AMMO_TYPES = 256;
	public const int MAX_AMMO_SLOTS = 256;
	public const int MAX_SPLINE_POINTS = 16;

	public static readonly Vector3 VECTOR_CONE_PRECALCULATED = vec3_origin;
	public static readonly Vector3 VECTOR_CONE_1DEGREES = new Vector3(0.00873f, 0.00873f, 0.00873f);
	public static readonly Vector3 VECTOR_CONE_2DEGREES = new Vector3(0.01745f, 0.01745f, 0.01745f);
	public static readonly Vector3 VECTOR_CONE_3DEGREES = new Vector3(0.02618f, 0.02618f, 0.02618f);
	public static readonly Vector3 VECTOR_CONE_4DEGREES = new Vector3(0.03490f, 0.03490f, 0.03490f);
	public static readonly Vector3 VECTOR_CONE_5DEGREES = new Vector3(0.04362f, 0.04362f, 0.04362f);
	public static readonly Vector3 VECTOR_CONE_6DEGREES = new Vector3(0.05234f, 0.05234f, 0.05234f);
	public static readonly Vector3 VECTOR_CONE_7DEGREES = new Vector3(0.06105f, 0.06105f, 0.06105f);
	public static readonly Vector3 VECTOR_CONE_8DEGREES = new Vector3(0.06976f, 0.06976f, 0.06976f);
	public static readonly Vector3 VECTOR_CONE_9DEGREES = new Vector3(0.07846f, 0.07846f, 0.07846f);
	public static readonly Vector3 VECTOR_CONE_10DEGREES = new Vector3(0.08716f, 0.08716f, 0.08716f);
	public static readonly Vector3 VECTOR_CONE_15DEGREES = new Vector3(0.13053f, 0.13053f, 0.13053f);
	public static readonly Vector3 VECTOR_CONE_20DEGREES = new Vector3(0.17365f, 0.17365f, 0.17365f);

	public const int kActivityLookup_Unknown = -2;          // hasn't been searched for
	public const int kActivityLookup_Missing = -1;          // has been searched for but wasn't found


	public static ClientClass WithManualClassID(this ClientClass clientClass, StaticClassIndices classID) {
		clientClass.ClassID = (int)classID;
		return clientClass;
	}

	public static ServerClass WithManualClassID(this ServerClass clientClass, StaticClassIndices classID) {
		clientClass.ClassID = (int)classID;
		return clientClass;
	}
}

public enum WeaponState
{
	NotCarried = 0,
	IsCarriedByPlayer = 1,
	IsActive = 2,
	IsOnTarget = 0x40
}

public enum PassengerRole
{
	None = -1,
	Driver = 0,
	LastSharedVehicleRole
}


public enum HitGroup
{
	Generic = 0,
	Head = 1,
	Chest = 2,
	Stomach = 3,
	LeftArm = 4,
	RightArm = 5,
	LeftLeg = 6,
	RightLeg = 7,
	Gear = 10
}

public enum PlayerAnim
{
	Idle,
	Walk,
	Jump,
	SuperJump,
	Die,
	Attack1,
	InVehicle,
	Reload,
	StartAiming,
	LeaveAiming,
}

public enum FireBulletsFlags
{

}

public struct FireBulletsInfo
{
	public FireBulletsInfo() {
		Shots = 1;
		Spread.Init(0, 0, 0);
		Distance = 8192;
		TracerFreq = 4;
		Damage = 0;
		PlayerDamage = 0;
		Attacker = null;
		Flags = 0;
		AdditionalIgnoreEnt = null;
		DamageForceScale = 1.0f;

#if DEBUG
		AmmoType = -1;
		Src.Init(float.NaN, float.NaN, float.NaN);
		DirShooting.Init(float.NaN, float.NaN, float.NaN);
#endif
		PrimaryAttack = true;
		UseServerRandomSeed = false;
	}

	public FireBulletsInfo(int shots, in Vector3 src, in Vector3 dir, in Vector3 spread, float distance, int ammoType, bool primaryAttack = true) {
		Shots = shots;
		Src = src;
		DirShooting = dir;
		Spread = spread;
		Distance = distance;
		AmmoType = ammoType;
		TracerFreq = 4;
		Damage = 0;
		PlayerDamage = 0;
		Attacker = null;
		Flags = 0;
		AdditionalIgnoreEnt = null;
		DamageForceScale = 1.0f;
		PrimaryAttack = primaryAttack;
		UseServerRandomSeed = false;
	}

	public int Shots;
	public Vector3 Src;
	public Vector3 DirShooting;
	public Vector3 Spread;
	public float Distance;
	public int AmmoType;
	public int TracerFreq;
	public float Damage;
	public int PlayerDamage;    // Damage to be used instead of m_flDamage if we hit a player
	public FireBulletsFlags Flags;           // See FireBulletsFlags_t
	public float DamageForceScale;
#if CLIENT_DLL || GAME_DLL
	public SharedBaseEntity? Attacker;
	public SharedBaseEntity? AdditionalIgnoreEnt;
#else
	public object? Attacker;
	public object? AdditionalIgnoreEnt;
#endif
	public bool PrimaryAttack;
	public bool UseServerRandomSeed;
}


public enum HideHudBits
{
	WeaponSelection = 1 << 0,
	Flashlight = 1 << 1,
	All = 1 << 2,
	Health = 1 << 3,
	PlayerDead = 1 << 4,
	NeedSuit = 1 << 5,
	MiscStatus = 1 << 6,
	Chat = 1 << 7,
	Crosshair = 1 << 8,
	VehicleCrosshair = 1 << 9,
	InVehicle = 1 << 10,
	BonusProgress = 1 << 11,

	BitCount = 12
}


[InlineArray(NUM_AUDIO_LOCAL_SOUNDS)] public struct InlineArrayNumLocalAudioSounds<T> { public T item; }
[InlineArray(MAX_AMMO_TYPES)] public struct InlineArrayMaxAmmoTypes<T> { public T item; }
[InlineArray(MAX_AMMO_SLOTS)] public struct InlineArrayMaxAmmoSlots<T> { public T item; }
[InlineArray(NetFlow.MAX_FLOWS)] public struct InlineArrayMaxFlows<T> { public T item; }
[InlineArray(MAX_SPLINE_POINTS)] public struct InlineArrayMaxSplinePoints<T> { public T item; }
[InlineArray(Constants.MAX_PLAYERS)] public struct InlineArrayMaxPlayers<T> { public T item; }
[InlineArray(Constants.MAX_PLAYERS + 1)] public struct InlineArrayMaxPlayersPlusOne<T> { public T item; }

[InlineArray(MAX_WEAPONS)]
public struct InlineArrayNewMaxWeapons<T> where T : new()
{
	public T item;
	public InlineArrayNewMaxWeapons() { for (int i = 0; i < MAX_WEAPONS; i++) this[i] = new(); }
}


[InlineArray(MAX_VIEWMODELS)]
public struct InlineArrayNewMaxViewmodels<T> where T : new()
{
	public T item;
	public InlineArrayNewMaxViewmodels() { for (int i = 0; i < MAX_VIEWMODELS; i++) this[i] = new(); }
}
[InlineArray(Constants.MAX_PLAYERS)]
public struct InlineArrayNewMaxPlayers<T> where T : new()
{
	public T item;
	public InlineArrayNewMaxPlayers() { for (int i = 0; i < MAX_VIEWMODELS; i++) this[i] = new(); }
}

[InlineArray(Constants.MAX_PLAYERS + 1)]
public struct InlineArrayNewMaxPlayersPlus1<T> where T : new()
{
	public T item;
	public InlineArrayNewMaxPlayersPlus1() { for (int i = 0; i < MAX_VIEWMODELS; i++) this[i] = new(); }
}

[InlineArray(MAX_BEAM_ENTS)]
public struct InlineArrayNewMaxBeamEnts<T> where T : new()
{
	public T item;
	public InlineArrayNewMaxBeamEnts() { for (int i = 0; i < MAX_BEAM_ENTS; i++) this[i] = new(); }
}



[InlineArray(kMAXCONTROLPOINTS)]
public struct InlineArrayNewMaxControlPoints<T> where T : new()
{
	public const int kMAXCONTROLPOINTS = 63;
	public T item;
	public InlineArrayNewMaxControlPoints() { for (int i = 0; i < kMAXCONTROLPOINTS; i++) this[i] = new(); }
}
