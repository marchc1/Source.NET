using CommunityToolkit.HighPerformance;

using Source.Common.DataCache;
using Source.Common.MaterialSystem;

using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Source.Common;

public static class Studio
{
	public const int STUDIO_VERSION = 48;

	public const int MAXSTUDIOTRIANGLES = 65536;
	public const int MAXSTUDIOVERTS = 65536;
	public const int MAXSTUDIOFLEXVERTS = 10000;

	public const int MAXSTUDIOSKINS = 32;
	public const int MAXSTUDIOBONES = 128;
	public const int MAXSTUDIOFLEXDESC = 1024;
	public const int MAXSTUDIOFLEXCTRL = 96;
	public const int MAXSTUDIOPOSEPARAM = 24;
	public const int MAXSTUDIOBONECTRLS = 4;
	public const int MAXSTUDIOANIMBLOCKS = 256;

	public const int MAX_NUM_LODS = 8;
	public const int MAX_NUM_BONES_PER_VERT = 3;

	public const int MAXSTUDIOBONEBITS = 7;

	public const int MODEL_VERTEX_FILE_ID = (('V' << 24) + ('S' << 16) + ('D' << 8) + 'I');
	public const int MODEL_VERTEX_FILE_VERSION = 4;
	public const int MODEL_VERTEX_FILE_THIN_ID = (('V' << 24) + ('C' << 16) + ('D' << 8) + 'I');

	public const int BONE_CALCULATE_MASK = 0x1F;
	public const int BONE_PHYSICALLY_SIMULATED = 0x01;
	public const int BONE_PHYSICS_PROCEDURAL = 0x02;
	public const int BONE_ALWAYS_PROCEDURAL = 0x04;
	public const int BONE_SCREEN_ALIGN_SPHERE = 0x08;
	public const int BONE_SCREEN_ALIGN_CYLINDER = 0x10;

	public const int BONE_USED_MASK = 0x0007FF00;
	public const int BONE_USED_BY_ANYTHING = 0x0007FF00;
	public const int BONE_USED_BY_HITBOX = 0x00000100;
	public const int BONE_USED_BY_ATTACHMENT = 0x00000200;
	public const int BONE_USED_BY_VERTEX_MASK = 0x0003FC00;
	public const int BONE_USED_BY_VERTEX_LOD0 = 0x00000400;
	public const int BONE_USED_BY_VERTEX_LOD1 = 0x00000800;
	public const int BONE_USED_BY_VERTEX_LOD2 = 0x00001000;
	public const int BONE_USED_BY_VERTEX_LOD3 = 0x00002000;
	public const int BONE_USED_BY_VERTEX_LOD4 = 0x00004000;
	public const int BONE_USED_BY_VERTEX_LOD5 = 0x00008000;
	public const int BONE_USED_BY_VERTEX_LOD6 = 0x00010000;
	public const int BONE_USED_BY_VERTEX_LOD7 = 0x00020000;
	public const int BONE_USED_BY_BONE_MERGE = 0x00040000;

	public static int BONE_USED_BY_VERTEX_AT_LOD(int lod) => BONE_USED_BY_VERTEX_LOD0 << lod;
}

public enum StudioHdrFlags
{
	AutoGeneratedHitbox = 0x00000001,
	UsesEnvCubemap = 0x00000002,
	ForceOpaque = 0x00000004,
	TranslucentTwoPass = 0x00000008,
	StaticProp = 0x00000010,
	UsesFbTexture = 0x00000020,
	HasShadowLod = 0x00000040,
	UsesBumpmapping = 0x00000080,
	UseShadowLodMaterials = 0x00000100,
	Obsolete = 0x00000200,
	Unused = 0x00000400,
	NoForcedFade = 0x00000800,
	ForcePhonemeCrossfade = 0x00001000,
	ConstantDirectionalLightDot = 0x00002000,
	FlexesConverted = 0x00004000,
	BuiltInPreviewMode = 0x00008000,
	AmbientBoost = 0x00010000,
	DoNotCastShadows = 0x00020000,
	CastTextureShadows = 0x00040000,
	VertAnimFixedPointScale = 0x00200000
}


[InlineArray(Studio.MAX_NUM_LODS)] public struct InlineArrayMaxNumLODs<T> { T first; }
[InlineArray(Studio.MAX_NUM_BONES_PER_VERT)] public struct InlineArrayMaxNumBonesPerVert<T> { T first; }

public class VirtualGroup
{
	public object? Cache;
	public readonly List<int> BoneMap = [];
	public readonly List<int> MasterBone = [];
	public readonly List<int> MasterSeq = [];
	public readonly List<int> MasterAnim = [];
	public readonly List<int> MasterAttachment = [];
	public readonly List<int> MasterPose = [];
	public readonly List<int> MasterNode = [];
}

public class VirtualSequence
{
	public int Flags;
	public int Activity;
	public int Group;
	public int Index;
}

public class VirtualGeneric
{
	public int Group;
	public int Index;
}

public class VirtualModel
{
	public void AppendSequences(int group, StudioHeader studioHDR) {

	}
	public void AppendAnimations(int group, StudioHeader studioHDR) {

	}
	public void AppendAttachments(int group, StudioHeader studioHDR) {

	}
	public void AppendPoseParameters(int group, StudioHeader studioHDR) {

	}
	public void AppendBonemap(int group, StudioHeader studioHDR) {

	}
	public void AppendNodes(int group, StudioHeader studioHDR) {

	}
	public void AppendTransitions(int group, StudioHeader studioHDR) {

	}
	public void AppendIKLocks(int group, StudioHeader studioHDR) {

	}
	public void AppendModels(int group, StudioHeader studioHDR) {
		AppendSequences(group, studioHDR);
		AppendAnimations(group, studioHDR);
		AppendBonemap(group, studioHDR);
		AppendAttachments(group, studioHDR);
		AppendPoseParameters(group, studioHDR);
		AppendNodes(group, studioHDR);
		AppendIKLocks(group, studioHDR);
		// todo

		UpdateAutoplaySequences(studioHDR);
	}
	public void UpdateAutoplaySequences(StudioHeader studioHDR) {

	}

	public VirtualGroup AnimGroup(int animation) {
		throw new NotImplementedException();
	}
	public VirtualGroup SeqGroup(int sequence) {
		throw new NotImplementedException();
	}

	// TODO
	// public readonly Mutex Lock = new();

	public readonly List<VirtualSequence> Seq = [];
	public readonly List<VirtualGeneric> Anim = [];
	public readonly List<VirtualGeneric> Attachment = [];
	public readonly List<VirtualGeneric> Pose = [];
	public readonly List<VirtualGroup> Group = [];
	public readonly List<VirtualGeneric> Node = [];
	public readonly List<VirtualGeneric> IKLock = [];
	public readonly List<ushort> AutoplaySequences = [];
}

public enum StudioMeshGroupFlags {
	IsFlexed = 0x1,
	IsHWSkinned = 0x2,
	IsDeltaFlexed = 0x4,
}

public class StudioMeshGroup {
	public IMesh? Mesh;
	public int NumStrips;
	public StudioMeshGroupFlags Flags;
	public ushort[]? GroupIndexToMeshIndex;
	public int NumVertices;
	public ushort[]? Indices;
	public bool MeshNeedsRestore;
	public int ColorMeshID;
	// IMorph?

	public ushort MeshIndex(int i) => GroupIndexToMeshIndex![Indices![i]];
}

public class StudioMeshData {
	public int NumGroup;
	public StudioMeshGroup? MeshGroup;
}

public class StudioLODData
{
	public StudioMeshData? MeshData;
	public float SwitchPoint;
	public IMaterial[]? Materials;
	public int[]? MaterialFlags;
}

public class StudioHWData
{
	public int RootLOD;
	public int NumLODs;
	public StudioLODData[]? LODs;
	public int NumStudioMeshes;

	public int GetLODForMetric(float metric) {
		throw new NotImplementedException();
	}

	public float LODMetric(float screenSize) {
		throw new NotImplementedException();
	}
}

public struct MStudioBoneWeight
{
	public InlineArrayMaxNumBonesPerVert<float> Weight;
	public InlineArrayMaxNumBonesPerVert<float> Bone;
	public byte NumBones;
}

public struct MStudioModelVertexData
{
	public object? VertexData;
	public object? TangentData;

	public readonly object? GetVertexData() => VertexData;
	public readonly T? GetVertexData<T>() => (T?)VertexData;
	public readonly object? GetTangentData() => TangentData;
	public readonly T? GetTangentData<T>() => (T?)TangentData;

	public readonly ref Vector3 Position(int i) => throw new NotImplementedException();
	public readonly ref Vector3 Normal(int i) => throw new NotImplementedException();
	public readonly ref Vector4 TangentS(int i) => throw new NotImplementedException();
	public readonly ref Vector2 TexCoord(int i) => throw new NotImplementedException();
	public readonly ref MStudioBoneWeight BoneWeights(int i) => throw new NotImplementedException();
	public readonly ref MStudioVertex Vertex(int i) => throw new NotImplementedException();

	// todo: verify
	public readonly bool HasTangentData() => TangentData != null;
}

public class MStudioModel
{
	Memory<byte> Data;
	[StructLayout(LayoutKind.Explicit)]
	internal struct __contents
	{
		[FieldOffset(0)] public InlineArray64<byte> Name;
		[FieldOffset(64)] public int Type;
		[FieldOffset(68)] public float BoundingRadius;
		[FieldOffset(72)] public int NumMeshes;
		[FieldOffset(76)] public int MeshIndex;
		[FieldOffset(80)] public int NumVertices;
		[FieldOffset(84)] public int VertexIndex;
		[FieldOffset(88)] public int TangentsIndex;
		[FieldOffset(92)] public int NumAttachments;
		[FieldOffset(96)] public int AttachmentIndex;
		[FieldOffset(100)] public int NumEyeballs;
		[FieldOffset(104)] public int EyeballIndex;

		// these are pointers which will instead be class instance refs OUTSIDE of the contents.
		// But we need to parse unused data anyway here for the pointers, so
		[FieldOffset(108)] InlineArray40<byte> unused;
	}
	__contents Contents;


	public ref int Type { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.Type; }
	public ref float BoundingRadius { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.BoundingRadius; }
	public ref int NumMeshes { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.NumMeshes; }
	public ref int MeshIndex { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.MeshIndex; }
	public ref int NumVertices { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.NumVertices; }
	public ref int VertexIndex { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.VertexIndex; }
	public ref int TangentsIndex { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.TangentsIndex; }
	public ref int NumAttachments { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.NumAttachments; }
	public ref int AttachmentIndex { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.AttachmentIndex; }
	public ref int NumEyeballs { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.NumEyeballs; }
	public ref int EyeballIndex { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref Contents.EyeballIndex; }

	public MStudioModelVertexData VertexData;

	public MStudioModel(Memory<byte> data) {
		Data = data;
		Contents = data.Span.Cast<byte, __contents>()[0];
	}

	string? nameCache;
	public string Name() {
		if (nameCache == null) {
			using ASCIIStringView strView = new(Contents.Name);
			nameCache = new(strView);
		}
		return nameCache;
	}

	public ref readonly MStudioModelVertexData GetVertexData() => ref VertexData;
}

public class MStudioBodyParts(Memory<byte> Data)
{
	public int SzNameIndex => MemoryMarshal.Cast<byte, int>(Data.Span)[0];
	public int NumModels => MemoryMarshal.Cast<byte, int>(Data.Span)[1];
	public int Base => MemoryMarshal.Cast<byte, int>(Data.Span)[2];
	public int ModelIndex => MemoryMarshal.Cast<byte, int>(Data.Span)[3];


	string? nameCache;
	public string Name() {
		if (nameCache == null) {
			using ASCIIStringView strView = new(Data.Span[SzNameIndex..]);
			nameCache = new(strView);
		}
		return nameCache;
	}

	MStudioModel[]? studioModelCache;

	public MStudioModel Model(int i) {
		if (studioModelCache == null)
			studioModelCache = new MStudioModel[NumModels];

		ArgumentOutOfRangeException.ThrowIfLessThan(i, 0);
		ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(i, NumModels);

		if (studioModelCache[i] == null)
			return studioModelCache[i] = new(Data[(ModelIndex + (i * Unsafe.SizeOf<MStudioModel.__contents>()))..]);
		return studioModelCache[i];
	}
}

public struct MStudioVertex
{
	public MStudioBoneWeight BoneWeights;
	public Vector3 Position;
	public Vector3 Normal;
	public Vector2 TexCoord;
}

public class VertexFileHeader
{
	public Memory<byte> Data;

	public VertexFileHeader(byte[] data) {
		Data = data;
		using BinaryReader br = new(new MemoryStream(data), System.Text.Encoding.ASCII);
		ID = br.ReadInt32();
		Version = br.ReadInt32();
		Checksum = br.ReadInt32();
		NumLODs = br.ReadInt32();
		for (int i = 0; i < Studio.MAX_NUM_LODS; i++)
			NumLODVertices[i] = br.ReadInt32();

		NumFixups = br.ReadInt32();
		FixupTableStart = br.ReadInt32();
		VertexDataStart = br.ReadInt32();
		tangentDataStart = br.ReadInt32();
	}

	public int ID;
	public int Version;
	public int Checksum;
	public int NumLODs;
	public InlineArrayMaxNumLODs<int> NumLODVertices;
	public int NumFixups;
	public int FixupTableStart;
	public int VertexDataStart;
	public int tangentDataStart;

	public ReadOnlySpan<MStudioVertex> GetVertexData() {
		if (ID == Studio.MODEL_VERTEX_FILE_ID && VertexDataStart != 0)
			return Data.Span[VertexDataStart..].Cast<byte, MStudioVertex>();
		else
			return null;
	}
}

public class StudioHeader2
{
	public Memory<byte> Data;

	public int NumSrcBoneTransform;
	public int SrcBoneTransformIndex;
	public int IllumPositionAttachmentIndex;
	public float MaxEyeDeflection;
	public int LinearBoneIndex;
	public int SzNameIndex;
	public int BoneFlexDriverCount;
	public int BoneFlexDriverIndex;
	public InlineArray56<int> Reserved;
}

public struct MStudioTexture
{
	public const int SIZE_OF_ONE = (sizeof(int) * 4)  // Name, flags, used, unused.
								 + (sizeof(int) * 2)  // The two pointers
								 + (sizeof(int) * 10) // The other unused data
		;

	public Memory<byte> Data;
	public readonly int NameIndex => Data.Span.Cast<byte, int>()[0];
	public readonly int Flags => Data.Span.Cast<byte, int>()[1];
	public readonly int Used => Data.Span.Cast<byte, int>()[2];
	public readonly int Unused => Data.Span.Cast<byte, int>()[3];
	public ReadOnlySpan<char> Name() => ""; // TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
}

/// <summary>
/// Analog of CStudioHdr
/// </summary>
public class StudioHdr
{
	public bool IsVirtual() => vModel != null;
	public bool IsValid() => studioHdr != null;
	public bool IsReadyForAccess() => studioHdr != null;

	public VirtualModel GetVirtualModel() => vModel!;
	public StudioHeader GetRenderHdr() => studioHdr!;

	private StudioHeader? studioHdr;
	private VirtualModel? vModel;
	public int NumBones() => studioHdr!.NumBones;
	readonly List<StudioHeader> StudioHdrCache = [];

	public void Init(StudioHeader? studioHdr, IMDLCache mdlcache) {
		this.studioHdr = studioHdr;

		this.vModel = null;
		StudioHdrCache.Clear();

		if (this.studioHdr == null)
			return;
		// todo the rest
	}
}

/// <summary>
/// Analog of studiohdr_t
/// </summary>
public class StudioHeader
{
	private StudioHeader() { }
	public StudioHeader(Memory<byte> data) {
		Data = data;
	}
	public readonly Memory<byte> Data;

	public int ID;
	public int Version;
	public int Checksum;
	public InlineArray64<char> Name;
	public int Length;

	public Vector3 EyePosition;
	public Vector3 IllumPosition;
	public Vector3 HullMin;
	public Vector3 HullMax;
	public Vector3 ViewBoundingBoxMin;
	public Vector3 ViewBoundingBoxMax;
	public StudioHdrFlags Flags;

	public int NumBones;
	public int BoneIndex;

	public int NumBoneControllers;
	public int BoneControllerIndex;

	public int NumHitboxSets;
	public int HitboxSetIndex;

	public int NumLocalAnim;
	public int LocalAnimIndex;

	public int NumLocalSeq;
	public int LocalSeqIndex;

	public int ActivityListVersion;
	public int EventsIndexed;

	public int NumTextures;
	public int TextureIndex;
	public MStudioTexture Texture(int i) => new() {
		Data = Data[(TextureIndex + (MStudioTexture.SIZE_OF_ONE * i))..]
	};

	public int NumCDTextures;
	public int CDTextureIndex;
	string[]? cdTextureCache;
	public ReadOnlySpan<char> CDTexture(int i) {
		if (cdTextureCache == null)
			cdTextureCache = new string[NumCDTextures];

		if (cdTextureCache[i] != null)
			return cdTextureCache[i];

		Span<byte> span = Data.Span;

		var offsetTable = MemoryMarshal.Cast<byte, int>(span[CDTextureIndex..]);
		int stringOffset = offsetTable[i];
		var strBytes = span[stringOffset..];

		using ASCIIStringView ascii = new(strBytes);
		cdTextureCache[i] = new(ascii);
		return cdTextureCache[i];
	}

	/// <summary>
	/// pszName equiv
	/// </summary>
	public ReadOnlySpan<char> GetName() {
		// TODO: studiohdr2 index

		return ((ReadOnlySpan<char>)Name).SliceNullTerminatedString();
	}

	MStudioBodyParts[]? bodyPartCache;

	public MStudioBodyParts BodyPart(int i) {
		if (bodyPartCache == null)
			bodyPartCache = new MStudioBodyParts[NumBodyParts];

		ArgumentOutOfRangeException.ThrowIfLessThan(i, 0);
		ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(i, NumBodyParts);

		if (bodyPartCache[i] == null)
			return bodyPartCache[i] = new(Data[BodyPartIndex..]);
		return bodyPartCache[i];
	}

	public int NumSkinRef;
	public int NumSkinFamilies;
	public int SkinIndex;

	public int NumBodyParts;
	public int BodyPartIndex;

	public int NumLocalAttachments;
	public int LocalAttachmentIndex;

	public int NumLocalNodes;
	public int LocalNodeIndex;
	public int LocalNodeNameIndex;

	public int NumFlexDesc;
	public int FlexDescIndex;

	public int NumFlexControllers;
	public int FlexControllerIndex;

	public int NumFlexRules;
	public int FlexRuleIndex;

	public int NumIKChains;
	public int IKChainIndex;

	public int NumMouths;
	public int MouthIndex;

	public int NumLocalPoseParameters;
	public int LocalPoseParamIndex;

	public int SurfacePropIndex;
	public int KeyValueIndex;
	public int KeyValueSize;

	public int NumLocalIKAutoplayLocks;
	public int LocalIKAutoplayLockIndex;

	public float Mass;
	public int Contents;

	public int NumIncludeModels;
	public int IncludeModelIndex;

	public MDLHandle_t VirtualModel;

	public int SzAnimBlockNameIndex;
	public int NumAnimBlocks;
	public int AnimBlockIndex;
	public int AnimBlockModel;

	public int BoneTableByNameIndex;
	public int VertexBase;
	public int IndexBase;
	public byte ConstDirectionalLightDot;
	public byte RootLOD;
	public byte NumAllowedRootLODs;
	byte _UNUSED1;
	public int StudioHDR2Index;
	byte _UNUSED2;
	public int NumFlexControllerUI;
	public int FlexControllerUIIndex;
	public float VertAnimFixedPointScale;
}
