using System.Numerics;
using System.Runtime.CompilerServices;

namespace Source.Common;

public static class Studio
{
	public const int STUDIO_VERSION = 48;

	public const int MAXSTUDIOTRIANGLES = 65536;
	public const int MAXSTUDIOVERTS = 65536;
	public const int MAXSTUDIOFLEXVERTS = 10000;

	public const int MAXSTUDIOSKINS = 32;
	public const int MAXSTUDIOBONES = 128;
	public const int MAXSTUDIOFLEXDESC = 1024;
	public const int MAXSTUDIOFLEXCTRL = 96;
	public const int MAXSTUDIOPOSEPARAM = 24;
	public const int MAXSTUDIOBONECTRLS = 4;
	public const int MAXSTUDIOANIMBLOCKS = 256;

	public const int MAX_NUM_LODS = 8;

	public const int MAXSTUDIOBONEBITS = 7;
}

public enum StudioHdrFlags
{
	AutoGeneratedHitbox = 0x00000001,
	UsesEnvCubemap = 0x00000002,
	ForceOpaque = 0x00000004,
	TranslucentTwoPass = 0x00000008,
	StaticProp = 0x00000010,
	UsesFbTexture = 0x00000020,
	HasShadowLod = 0x00000040,
	UsesBumpmapping = 0x00000080,
	UseShadowLodMaterials = 0x00000100,
	Obsolete = 0x00000200,
	Unused = 0x00000400,
	NoForcedFade = 0x00000800,
	ForcePhonemeCrossfade = 0x00001000,
	ConstantDirectionalLightDot = 0x00002000,
	FlexesConverted = 0x00004000,
	BuiltInPreviewMode = 0x00008000,
	AmbientBoost = 0x00010000,
	DoNotCastShadows = 0x00020000,
	CastTextureShadows = 0x00040000,
	VertAnimFixedPointScale = 0x00200000
}


[InlineArray(Studio.MAX_NUM_LODS)] public struct InlineArrayMaxNumLODs<T> { T first; }

public class VirtualGroup
{
	public object? Cache;
	public readonly List<int> BoneMap = [];
	public readonly List<int> MasterBone = [];
	public readonly List<int> MasterSeq = [];
	public readonly List<int> MasterAnim = [];
	public readonly List<int> MasterAttachment = [];
	public readonly List<int> MasterPose = [];
	public readonly List<int> MasterNode = [];
}

public class VirtualSequence
{
	public int Flags;
	public int Activity;
	public int Group;
	public int Index;
}

public class VirtualGeneric
{
	public int Group;
	public int Index;
}

public class VirtualModel
{
	public void AppendSequences(int group, StudioHDR studioHDR) => throw new NotImplementedException();
	public void AppendAnimations(int group, StudioHDR studioHDR) => throw new NotImplementedException();
	public void AppendAttachments(int group, StudioHDR studioHDR) => throw new NotImplementedException();
	public void AppendPoseParameters(int group, StudioHDR studioHDR) => throw new NotImplementedException();
	public void AppendBonemap(int group, StudioHDR studioHDR) => throw new NotImplementedException();
	public void AppendNodes(int group, StudioHDR studioHDR) => throw new NotImplementedException();
	public void AppendTransitions(int group, StudioHDR studioHDR) => throw new NotImplementedException();
	public void AppendIKLocks(int group, StudioHDR studioHDR) => throw new NotImplementedException();
	public void AppendModels(int group, StudioHDR studioHDR) => throw new NotImplementedException();
	public void UpdateAutoplaySequences(int group, StudioHDR studioHDR) => throw new NotImplementedException();

	public VirtualGroup AnimGroup(int animation) => throw new NotImplementedException();
	public VirtualGroup SeqGroup(int sequence) => throw new NotImplementedException();

	// TODO
	// public readonly Mutex Lock = new();

	public readonly List<VirtualSequence> Seq = [];
	public readonly List<VirtualGeneric> Anim = [];
	public readonly List<VirtualGeneric> Attachment = [];
	public readonly List<VirtualGeneric> Pose = [];
	public readonly List<VirtualGroup> Group = [];
	public readonly List<VirtualGeneric> Node = [];
	public readonly List<VirtualGeneric> IKLock = [];
	public readonly List<ushort> AutoplaySequences = [];
}

public class StudioLODData
{

}

public class StudioHWData
{
	public int RootLOD;
	public int NumLODs;
	public StudioLODData[]? LODs;
	public int NumStudioMeshes;
}

public class VertexFileHeader
{
	public Memory<byte> Data;

	public int ID;
	public int Version;
	public int Checksum;
	public int NumLODs;
	public InlineArrayMaxNumLODs<int> NumLODVertices;
	public int NumFixups;
	public int FixupTableStart;
	public int VertexTableStart;
	public int TangentTableStart;
}

public class StudioHDR2
{
	public Memory<byte> Data;

	public int NumSrcBoneTransform;
	public int SrcBoneTransformIndex;
	public int IllumPositionAttachmentIndex;
	public float MaxEyeDeflection;
	public int LinearBoneIndex;
	public int SzNameIndex;
	public int BoneFlexDriverCount;
	public int BoneFlexDriverIndex;
	public InlineArray56<int> Reserved;
}

public class MStudioTexture
{
	public Memory<byte> Data;
	public ReadOnlySpan<char> Name() => ""; // TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
}

public class StudioHDR
{
	public Memory<byte> Data;

	public int ID;
	public int Version;
	public int Checksum;
	public InlineArray64<char> Name;
	public int Length;

	public Vector3 EyePosition;
	public Vector3 IllumPosition;
	public Vector3 HullMin;
	public Vector3 HullMax;
	public Vector3 ViewBoundingBoxMin;
	public Vector3 ViewBoundingBoxMax;
	public StudioHdrFlags Flags; 

	public int NumBones;
	public int BoneIndex;

	public int NumBoneControllers;
	public int BoneControllerIndex;

	public int NumHitboxSets;
	public int HitboxSetIndex;

	public int NumLocalAnim;
	public int LocalAnimIndex;

	public int NumLocalSeq;
	public int LocalSeqIndex;

	public int ActivityListVersion;
	public int EventsIndexed;

	public int NumTextures;
	public int TextureIndex;
	public MStudioTexture Texture(int i) => new(); // TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
	// ^^ All these todos need to consider how we load MDL's and how we interface with them in C#. Since we want to use class instances rather than struct ref casting

	public int NumCDTextures;
	public int CDTextureIndex;
	public ReadOnlySpan<char> CDTexture(int i) => new(); // TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 

	/// <summary>
	/// pszName equiv
	/// </summary>
	public ReadOnlySpan<char> GetName() {
		// TODO: studiohdr2 index

		return ((ReadOnlySpan<char>)Name).SliceNullTerminatedString();
	}

	public int NumSkinRef;
	public int NumSkinFamilies;
	public int SkinIndex;

	public int NumBodyParts;
	public int BodyPartIndex;

	public int NumLocalAttachments;
	public int LocalAttachmentIndex;

	public int NumLocalNodes;
	public int LocalNodeIndex;
	public int LocalNodeNameIndex;

	public int NumFlexDesc;
	public int FlexDescIndex;

	public int NumFlexControllers;
	public int FlexControllerIndex;

	public int NumFlexRules;
	public int FlexRuleIndex;

	public int NumIKChains;
	public int IKChainIndex;

	public int NumMouths;
	public int MouthIndex;

	public int NumLocalPoseParameters;
	public int LocalPoseParamIndex;

	public int SurfacePropIndex;
	public int KeyValueIndex;
	public int KeyValueSize;

	public int NumLocalIKAutoplayLocks;
	public int LocalIKAutoplayLockIndex;

	public float Mass;
	public int Contents;

	public int NumIncludeModels;
	public int IncludeModelIndex;

	public MDLHandle_t VirtualModel;

	public int SzAnimBlockNameIndex;
	public int NumAnimBlocks;
	public int AnimBlockIndex;
	public int AnimBlockModel;

	public int BoneTableByNameIndex;
	public int VertexBase;
	public int IndexBase;
	public byte ConstDirectionalLightDot;
	public byte RootLOD;
	public byte NumAllowedRootLODs;
	byte _UNUSED1;
	public int StudioHDR2Index;
	byte _UNUSED2;
	public int NumFlexControllerUI;
	public int FlexControllerUIIndex;
	public float VertAnimFixedPointScale;
}
